Q.What is Sementic element?
Ans:Semantic elements are HTML tags that convey meaning about the content they enclose, both to developers and browsers. They help structure web pages in a way that's meaningful and accessible.
Using semantic elements helps with SEO, accessibility, and code readability. These elements allow search engines and screen readers to better understand the structure and purpose of the content on the page
Eample:Header tag, footer tag and Section tag.


Q.What is Difference between position relative and position absolute?
Ans.
position:relative
1.The element is positioned relative to its normal position in the document flow.
2.It does not affect the layout of other elements around it.
3.You can use the top, right, bottom, or left properties to move the element from its original position, but the space it originally occupied remains in place.


Position Absolute:
1.The element is positioned relative to its nearest positioned ancestor (i.e., an ancestor with a position of relative, absolute, or fixed). If there is no such ancestor, it will be positioned relative to the initial containing block (usually the <html> element).
2.It is removed from the normal document flow, meaning it doesn't affect the position of other elements around it.
3.You can use the top, right, bottom, or left properties to specify its position.


Q.What is flexbox?
Ans.Flexbox, short for 'Flexible Box Layout,' is a powerful layout model in CSS that helps create responsive, flexible web designs. It allows you to easily align, distribute, and space elements within a container, even when their size is dynamic or unknown.
With Flexbox, you can control the layout of elements along a row or column (one-dimensional layout),
Example:
centering content, creating navigation bars, or building complex grid systems without needing to use floats or positioning.
Common properties:
flex-direction: Controls the direction of flex items (horizontal or vertical).
justify-content: Aligns items along the main axis (e.g., horizontally in a row).
align-items: Aligns items along the cross axis (e.g., vertically in a row).
flex-grow, flex-shrink, flex-basis: Control how flex items grow, shrink, and their initial size.

Q.What is grid?
Ans:"CSS Grid Layout is a powerful two-dimensional layout system in CSS. Unlike Flexbox, which operates in one direction (either row or column), Grid allows you to work with both rows and columns at the same time. This makes it ideal for creating more complex layouts, such as grid-based designs, magazine-style layouts, or responsive web pages with multiple elements arranged in a structured way.

Key Features:
Grid Container: This is the parent element where you apply display: grid; to define a grid.
Grid Items: The child elements of the grid container that will be placed into the grid structure.
Key Properties:
grid-template-columns and grid-template-rows: These properties define how many columns and rows are in your grid and how wide/tall they should be.
For example, grid-template-columns: 1fr 2fr; would create two columns, with the second one twice as wide as the first.
grid-gap (or gap): Controls the spacing between rows and columns in the grid.
grid-template-areas: You can visually design grid layouts by naming specific areas (for example, "header", "sidebar", "content") and placing items into these areas.


Q.What is the differenece between flex and grid?
ans:

Q.What is box-modal?
ans."Box model in CSS is a fundamental concept that describes how the elements on a web page are structured and how their size is calculated. It defines the space taken by an element and how its content, padding, border, and margin interact with each other. Understanding the box model is crucial when designing layouts and ensuring elements fit and align properly.

The Box Model Components:
Content: This is the actual content of the element (e.g., text, images). The content area is where the text and other elements are rendered.

Padding: The space between the content and the border. Padding creates spacing inside the element, around the content.

Border: The border surrounds the padding (if any) and content. It can have a specified width, color, and style.

Margin: The space outside the border. Margins create space between the element and other surrounding elements.

Q.What is Eventloop?
Ans.The Event Loop is a fundamental part of how JavaScript handles asynchronous operations, particularly in environments like browsers and Node.js. It allows JavaScript to perform non-blocking operations, such as handling events, performing I/O operations, and running timers, without freezing or blocking the main thread of execution.

Here's how the event loop works:

Key Concepts:
Call Stack: This is where the JavaScript engine keeps track of function calls. The call stack is a simple LIFO (Last In, First Out) structure, meaning the most recently called function is always the one that gets executed next.

Heap: This is where dynamic memory allocation happens, i.e., where objects and variables are stored during runtime.

Message Queue (or Task Queue): This queue holds tasks (like event handlers or asynchronous callbacks) that are waiting to be executed. These tasks are typically things like:

Event listener callbacks (e.g., a click event).
Callback functions from asynchronous operations like setTimeout, setInterval, or network requests.
Event Loop: This is the mechanism that monitors both the call stack and the message queue. Its job is to keep checking if the call stack is empty, and if it is, it takes the first task from the message queue and pushes it onto the call stack for execution.


Q.What is DOM?
ans."DOM stands for Document Object Model, which is a programming interface for web documents. It represents the structure of a web page as a tree of nodes, where each node is an object representing parts of the document, such as elements, attributes, and text.

When a browser receives HTML or XML data from the server, it uses parsers to convert that structured data into a JavaScript-accessible DOM tree. This allows developers to interact with and dynamically update the content, structure, and styles of a webpage.

How the DOM Works:
Data from the Server: When the browser receives data (such as HTML, XML, or other structured formats) from the server, it needs a way to make this data interactive for scripts.

Parsing: The browser's built-in parsers convert the HTML (or similar structured data) into a structured JavaScript object model.

DOM Creation: The result is a hierarchical structure where:

HTML tags are represented as element nodes.
Text content becomes text nodes.
Attributes are attribute nodes.
Interactivity: JavaScript can dynamically update, add, or remove elements, styles, and event listeners within this model to create interactive and dynamic user experiences.

Q.What is VDOM?
"VDOM stands for Virtual Document Object Model. It's an abstraction of the actual DOM and is used to optimize updates and rendering in modern front-end frameworks like React.

In traditional DOM manipulation, every change in the UI triggers updates directly on the real DOM, which can be inefficient and slow due to its complex structure.

With the Virtual DOM, the process works differently:

When the state of a component changes, a Virtual DOM tree (a lightweight copy of the real DOM) is created and updated.
The framework compares the updated Virtual DOM with the previous version using a technique called diffing to detect changes.
After identifying the differences, only the necessary changes are applied to the real DOM, improving performance significantly.

Q.What is Hoisting?
"Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their containing scope during the compilation phase, even before the code is executed.

This means that you can use functions and variables in your code before they are declared, though the behavior differs for variables declared with var, let, and const.

Function Hoisting Example:
Functions declared with function are fully hoisted, so they can be called before their definition.


sayHello(); // Output: Hello World!

function sayHello() {
  console.log('Hello World!');
}

Variable Hoisting Example:
var declarations are partially hoisted — they are defined but initialized with undefined.


console.log(a); // Output: undefined
var a = 10;
However, variables declared with let and const are hoisted differently. They are placed in the Temporal Dead Zone (TDZ) until their declaration is encountered.


console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 20;

Q.What is closure?


Q.What is the difference between rest operator and Spread Operator
Rest Operator (...)
The rest operator collects multiple elements or properties into a single array or object. It is used in function parameters or destructuring assignments.
function sum(...numbers) {
  return numbers.reduce((acc, num) => acc + num, 0);
}

console.log(sum(1, 2, 3, 4)); // Output: 10


Spread Operator (...)
The spread operator expands elements of an array, object, or string into individual components. It's used to copy or merge arrays and objects.

const numbers = [1, 2, 3];
const newNumbers = [0, ...numbers, 4];
console.log(newNumbers); // [0, 1, 2, 3, 4]

Key Differences
Aspect	Rest Operator (...)	Spread Operator (...)
Purpose	Collects elements	Expands elements
Use Case	Function parameters, destructuring	Array, object copying, merging
Functionality	Combines into a single variable	Breaks into individual values


Q. What is promise?
Answer:
"A Promise is an object in JavaScript that represents the eventual completion or failure of an asynchronous operation and its resulting value. It allows you to handle asynchronous operations in a cleaner and more manageable way compared to traditional callback functions."

States of a Promise:
A Promise has three states:

Pending: The initial state — operation is ongoing.
Fulfilled: The operation completed successfully.
Rejected: The operation failed.

const fetchData = new Promise((resolve, reject) => {
  const success = true; // Simulating an operation
  setTimeout(() => {
    if (success) {
      resolve("Data fetched successfully!");
    } else {
      reject("Failed to fetch data.");
    }
  }, 1000);
});

fetchData
  .then(response => console.log(response))  // Output: Data fetched successfully!
  .catch(error => console.error(error));

How It Works:
The Promise constructor takes a function with resolve and reject parameters.
If the operation succeeds, resolve() is called, transitioning the promise to the fulfilled state.
If it fails, reject() is called, transitioning it to the rejected state.
The .then() method handles the success scenario, and .catch() handles errors.

Q.What is callback hell?
"Callback Hell refers to a situation in JavaScript where multiple nested callback functions are used, creating code that becomes difficult to read, maintain, and debug. This often happens when handling asynchronous operations that depend on each other."

setTimeout(() => {
  console.log('Step 1');
  setTimeout(() => {
    console.log('Step 2');
    setTimeout(() => {
      console.log('Step 3');
    }, 1000);
  }, 1000);
}, 1000);

Q.What is the difference betwen splice and slice in js?
ans.
"splice() and slice() are both array methods in JavaScript, but they have distinct functionalities:
array.splice(startIndex, deleteCount, item1, item2, ..., itemN)


splice() (Mutates the Original Array):
Used to add, remove, or replace elements in an array.
Modifies the original array and returns the removed elements.

let fruits = ['apple', 'banana', 'mango', 'grape'];
fruits.splice(1, 2, 'orange', 'kiwi');
console.log(fruits); // ['apple', 'orange', 'kiwi', 'grape']



slice() (Does Not Mutate the Original Array):
Extracts a portion of an array without modifying the original.
Returns a shallow copy of the selected portion.
array.slice(startIndex, endIndex)


let fruits = ['apple', 'banana', 'mango', 'grape'];
let slicedFruits = fruits.slice(1, 3);
console.log(slicedFruits); // ['banana', 'mango']
console.log(fruits); // ['apple', 'banana', 'mango', 'grape']


Q.What is Map,Filter and Reducer?
Ans.

"map(), reduce(), and filter() are higher-order array methods in JavaScript that help manipulate and transform arrays efficiently."

1.map()-
map() is an array method in JavaScript that creates a new array by applying a provided function to each element of the original array. It does not modify the original array but returns a transformed version of it.

syntax:
array.map(callbackFunction(currentValue, index, array), thisArg);

example:
const numbers = [1, 2, 3, 4];
const squaredNumbers = numbers.map(num => num * num);
console.log(squaredNumbers); // [1, 4, 9, 16]

2.Filter()

Answer:
"filter() is an array method in JavaScript that creates a new array containing elements that satisfy a specific condition defined by a callback function. It does not modify the original array."

array.filter(callbackFunction(currentValue, index, array), thisArg);

const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6]

3.reducer()
reduce() is an array method in JavaScript that applies a reducer function to each element in the array and accumulates a single output value. It is commonly used for operations like summing up numbers, flattening arrays, or building complex objects."

syntax:
array.reduce(callbackFunction(accumulator, currentValue, index, array), initialValue);

const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
console.log(sum); // 10


Q.What is for-of and for-in?
ans:"for-of and for-in are both loops in JavaScript, but they are used for different types of data iteration."

for-in:
"for-in is a loop in JavaScript used to iterate over the enumerable properties (keys) of an object or the indices of an array. It returns the property/key names, not the values directly."

const person = { name: "Alice", age: 25, city: "New York" };

for (let key in person) {
  console.log(`${key}: ${person[key]}`);
}
// Output:
// name: Alice
// age: 25
// city: New York


for-of:
Answer:
"for-of is a loop in JavaScript used to iterate over iterable objects like arrays, strings, maps, sets, and more. It directly accesses the values of the elements rather than their indices or keys."

const fruits = ["apple", "banana", "grape"];
for (let fruit of fruits) {
  console.log(fruit);
}
// Output:
// apple
// banana
// grape


Q.What is Apply,call and bind?
Ans.:

Q.What is the difference between normal function and arrow function?
Ans.
"A normal function, also called a regular function or traditional function, is defined using the function keyword in JavaScript. It can be declared and called with its name, and it provides its own this context based on how it's invoked."

"An arrow function is a concise way to write functions introduced in ES6 (ECMAScript 2015). It uses the => syntax and does not have its own this or arguments object, making it ideal for callbacks and functional programming."

Q: How many types of scopes are in JavaScript?
Ans:"There are mainly three types of scopes in JavaScript: Global, Function, and Block scopes. Scope defines the accessibility and lifetime of variables."

1. Global Scope:
Variables declared outside any function or block are in the global scope.
They are accessible from anywhere in the code.

let globalVar = "I am global";

function showGlobalVar() {
  console.log(globalVar);
}

showGlobalVar(); // Output: I am global


2. Function Scope:
Variables declared inside a function are in the function scope.
They are accessible only within that function.

function showMessage() {
  let message = "Hello from function scope!";
  console.log(message);
}

showMessage(); // Output: Hello from function scope!
// console.log(message); // Error: message is not defined


3. Block Scope:
Variables declared with let or const inside a block ({}) are in block scope.
They are accessible only within that block.
{
  let blockVar = "I am block-scoped";
  console.log(blockVar); // Output: I am block-scoped
}
// console.log(blockVar); // Error: blockVar is not defined


Q: What is Lexical Scope in JavaScript?
Answer:
"Lexical scope in JavaScript means that the scope of a variable is determined by its position in the source code. Functions are executed with the scope in which they were defined, not where they are called."

function outerFunction() {
  let outerVar = "I am from outer";

  function innerFunction() {
    console.log(outerVar); // Can access outerVar due to lexical scope
  }

  innerFunction();
}

outerFunction();
// Output: I am from outer

Q.What is life cycle in functional component?
Ans.
"In React, functional components do not have traditional lifecycle methods like class components. Instead, lifecycle phases are managed using React Hooks, primarily useEffect. These hooks allow us to handle side effects such as data fetching, DOM updates, and subscriptions."

Lifecycle Phases in Functional Components:
1.Mounting (Component Initialization):

This phase happens when the component is rendered for the first time.
Use useEffect(() => {}, []); to handle tasks like fetching data or initializing state.
example

import { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    console.log("Component mounted!");
  }, []);

  return <h1>Hello, React!</h1>;
}


2.Updating (Re-rendering on State/Props Changes):

Occurs when the component's state or props change.
Use useEffect(() => {}, [dependency]); to run code when specific values change.
Example:
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`Count updated to: ${count}`);
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

3.Unmounting (Component Cleanup):

Occurs when the component is removed from the UI.
Use the cleanup function inside useEffect to handle cleanup tasks like canceling API calls or unsubscribing from events.

import { useEffect } from "react";

function Timer() {
  useEffect(() => {
    const interval = setInterval(() => {
      console.log("Timer running...");
    }, 1000);

    return () => {
      clearInterval(interval); // Cleanup when component unmounts
      console.log("Timer stopped.");
    };
  }, []);

  return <h1>Timer Component</h1>;
}




================================================================React/Next.js======================================================================================================
Q.Q.What is React.js?
Ans:"React.js is a popular JavaScript library developed by Meta (formerly Facebook) for building user interfaces (UIs), particularly for single-page applications (SPAs). It allows developers to create dynamic and responsive web applications using a component-based architecture."

Advantage:
1.Component-Based Architecture:
2.Virtual DOM
3.Declarative UI
4.Declarative UI
5.Unidirectional Data Flow:
Data flows in a single direction from parent components to child components, making it easier to debug and maintain.
6.Hooks (State and Lifecycle Management):Hooks like useState and useEffect allow developers to manage state and side effects in functional components.

Q.What is SPA?
Ans:"A Single-Page Application (SPA) is a web application or website that loads a single HTML page and dynamically updates the content without requiring a full page reload from the server. SPAs deliver a smooth, fast, and app-like user experience by handling most of the interactions on the client side."

How SPAs Work:
The initial request from the browser fetches the entire application shell (HTML, CSS, and JavaScript).
As users navigate within the app, the content is updated dynamically using AJAX calls or fetch API without reloading the entire page.
Client-side routing is used to render different views.

Common Features:
Dynamic Content Updates: Only the necessary data is fetched and rendered on the page.
Fast Performance: Since there are fewer full-page reloads, the application feels faster and smoother.

Example of SPAs:
Gmail: The entire mailbox interface updates dynamically as you navigate between folders.
Facebook: The page doesn't reload when you check notifications or messages.
Twitter: The timeline updates with infinite scrolling without refreshing.

Advantages of SPAs:
Faster Loading Time: After the initial load, content updates are faster.
Better User Experience: Smooth and seamless interactions.
Reduced Server Load: Fewer page requests to the server.
Code Reusability: Can share code between the front-end and back-end.


Q.What is Next.js?
Ans:"Next.js is a React framework built by Vercel that allows developers to build server-side rendered (SSR) and static web applications with ease. It provides features like routing, server-side rendering, static site generation, and API routes out of the box, making it a powerful solution for modern web development."

Key Features of Next.js:
1.Server-Side Rendering (SSR):

Fetches data and renders pages on the server before sending the HTML to the client.
Ideal for better SEO and faster page load times.

Q: What is JSX in React?
Answer:
"JSX stands for JavaScript XML, and it is a syntax extension for JavaScript used in React. It allows developers to write HTML-like code directly in JavaScript, which React then transforms into React elements using Babel behind the scenes."

Why Use JSX?
1.Readable and Maintainable Code: It makes the code more readable by combining the structure (HTML) with the logic (JavaScript).
2.Component-Based Architecture: Easy to build UI components by combining HTML markup and JavaScript in one place.
3.Compile-Time Optimizations: JSX is compiled into efficient JavaScript for the browser.

Q.What is Fragmentation?
Ans:"A Fragment in React is a special component provided by React to group multiple child elements without adding extra nodes to the DOM. It helps maintain cleaner and more optimized HTML structures."

Q.Why Promises Have Higher Precedence Than setTimeout() in JavaScript
In JavaScript's event loop, Promises have a higher priority than setTimeout() because of how they are scheduled in the Microtask Queue and Macrotask Queue.

Event Loop Breakdown
Call Stack: Executes synchronous code line by line.
Microtask Queue: Handles higher-priority asynchronous tasks, such as Promises (.then(), .catch(), .finally()) and MutationObserver callbacks.
Macrotask Queue: Handles lower-priority asynchronous tasks, such as setTimeout(), setInterval(), and I/O operations.

Execution Priority:
Microtasks (Promises) are executed immediately after the current synchronous code completes.
Macrotasks (setTimeout) are executed only after the entire Microtask Queue is emptied.

Why Use Fragment?
Avoids Extra Markup:

Wrapping elements in a <div> can clutter the HTML structure unnecessarily. Fragments solve this by avoiding unnecessary wrapper elements.
Improved Performance:

Fragments do not introduce extra nodes, which makes rendering more efficient.
Cleaner and Semantic HTML:

Keeps the structure of your HTML clean and free from redundant tags.

Why Use Fragment?
Avoids Extra Markup:

Wrapping elements in a <div> can clutter the HTML structure unnecessarily. Fragments solve this by avoiding unnecessary wrapper elements.
Improved Performance:

Fragments do not introduce extra nodes, which makes rendering more efficient.
Cleaner and Semantic HTML:

Keeps the structure of your HTML clean and free from redundant tags.

Q.What is useCallback hook?
Ans.The useCallback hook is a built-in hook in React that allows you to memoize functions to prevent unnecessary re-creations on every render. It is useful when passing functions as props to child components or when a function depends on certain values.

const memoizedCallback = useCallback(() => {
  // Function logic
}, [dependencies]);

Why Use useCallback?
Performance Optimization: Prevents child components from being unnecessarily re-rendered by ensuring the same function instance is passed.

Stable Function References: Useful when functions are passed as dependencies to other hooks like useEffect or as props to child components.

Q.What is useMemo hooks?
Ans.The useMemo hook in React is used to memoize the result of a computation and optimize performance by avoiding unnecessary recalculations during re-renders. It ensures that the function only recomputes the value when its dependencies change.

example
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

Parameters:
1.Callback Function: A function that contains the expensive computation logic.
2.Dependency Array: Variables that the computation depends on. The callback is re-executed only if any of these values change.

Why Use useMemo?
1.Performance Optimization: Avoids re-running heavy computations during every render.
2.Referential Stability: Helps maintain stable references for computed values, especially when passed as props to child components.

What is react.strict?
Ans:React.StrictMode is a tool in React used to highlight potential issues in an application during development. It helps identify unsafe lifecycle methods, side effects, and deprecated APIs, promoting better coding practices and ensuring future compatibility with React updates.

Q: What is the useState Hook?
Ans: The useState hook in React is a built-in function that allows you to add state management to functional components. It enables components to maintain and update local state values, making them dynamic and interactive.
syntax:
const [state, setState] = useState(initialValue);

Parameters:
initialValue: The initial state value (can be a string, number, boolean, array, object, or even a function).
Returns:
state: The current state value.
setState: A function to update the state.

Q.What is useEffect?
ans: The useEffect hook in React allows you to perform side effects in functional components. It replaces lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount in class components.

useEffect(() => {
  // Side effect logic
  return () => {
    // Cleanup logic (optional)
  };
}, [dependencies]);
Parameters:
Callback Function: Contains the side effect logic and optional cleanup.
Dependencies (array): Determines when the effect should run. React will re-run the effect only if one or more dependencies change.

Q.What is useReducer hook?

Ans: The useReducer hook in React is an alternative to useState for managing complex state logic. It allows state transitions based on specific actions and is particularly useful when the state involves multiple sub-values or complex updates.

const [state, dispatch] = useReducer(reducer, initialState);

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}


Q.How can we pass data from child component to parent component?
Ans:In React, data is typically passed from parent to child via props. However, to pass data from a child component to a parent, the parent needs to provide a callback function that the child can call with the data as an argument.


Steps to Pass Data from Child to Parent
Define a function in the parent component.
Pass the function as a prop to the child component.
Call the function from the child component and pass the data.

Alternative Methods
State Management Libraries: Use Redux, Zustand, or Recoil for large-scale applications.
Context API: Share state across components without explicit prop drilling.
Event Emitters: For non-React systems, though less common in React itself.

Q: What is Props Drilling?
Ans: Props drilling is a pattern in React where data is passed from a parent component to deeply nested child components through multiple layers of intermediary components. Each intermediate component must pass the props down, even if they do not directly use the data.

Q.What is the difference between props and state?


Q.What is Higher order components?
Ans. 

Q.What are API methods?
Ans. 

